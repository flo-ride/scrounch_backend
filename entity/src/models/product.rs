//! Defines the `Product` entity, representing a product in the database schema.
//!
//! This entity is managed by SeaORM and includes fields that correspond to
//! columns in the `product` table.
//! `SeaORM` Entity. Generated by sea-orm-codegen 0.12.15.

use super::sea_orm_active_enums::{Currency, Unit};
use sea_orm::{entity::prelude::*, ActiveValue::Set};
use serde::{Deserialize, Serialize};

/// Represents the `product` entity in the database, encompassing details about
/// the products available for sale, including pricing, quantities, and images.
#[derive(
    Clone,
    Debug,
    PartialEq,
    DeriveEntityModel,
    Eq,
    Serialize,
    Deserialize,
    proc::DeriveToFilterQuery,
    proc::DeriveToSortQuery,
)]
#[sea_orm(table_name = "product")]
pub struct Model {
    /// Unique identifier for the product. Primary key, non-auto-incrementing.
    #[sea_orm(primary_key, auto_increment = false)]
    pub id: Uuid,

    /// Optional URL or path to the product image.
    pub image: Option<String>,

    /// Name of the product, required for identification.
    pub name: String,

    /// Display Order of the product inside of lists, 0 is last + default
    #[sea_orm(filter_plus_order)]
    pub display_order: i32,

    /// Selling Price of the product, stored as a decimal with up to 10 digits
    /// and 2 decimal places.
    #[sea_orm(column_type = "Decimal(Some((10, 2)))", nullable)]
    pub sell_price: Option<Decimal>,

    /// Selling Price Currency for the product,
    #[sea_orm(filter_override = "crate::request::r#enum::CurrencyRequest")]
    pub sell_price_currency: Option<Currency>,

    /// Represent the unit type of Product, if it's a liquid -> Liter, etc..., the default is Unit
    #[sea_orm(filter_override = "crate::request::r#enum::UnitRequest")]
    pub unit: Unit,

    /// Optional maximum quantity that can be ordered in a single command.
    pub max_quantity_per_command: Option<i16>,

    /// If the product is purchasable or if it's just an ingredients
    #[sea_orm(filter_single)]
    pub purchasable: bool,

    /// If the product is visible for user.
    #[sea_orm(filter_single)]
    pub hidden: bool,

    /// Indicates if the product is currently disabled for sale.
    #[sea_orm(filter_single)]
    pub disabled: bool,

    /// Timestamp indicating when the product was created in the system.
    #[sea_orm(filter_override = "chrono::DateTime<chrono::Utc>", filter_plus_order)]
    pub created_at: DateTimeWithTimeZone,

    /// Optional unique code for the product used by the Sma system.
    #[sea_orm(unique)]
    pub sma_code: Option<String>,

    /// Optional unique code for parts product used by Inventree (IPN) .
    #[sea_orm(unique)]
    pub inventree_code: Option<String>,
}

/// Enum representing the relations of the `Product` entity.
///
/// Currently, there are no defined relations for the `Product` entity,
/// but this enum can be expanded in the future if needed.
#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    /// For the Recipe
    #[sea_orm(has_many = "super::recipe::Entity")]
    Recipe,
    /// For the Recipe Ingredients
    #[sea_orm(has_many = "super::recipe_ingredients::Entity")]
    RecipeIngredients,
}

impl Related<super::recipe_ingredients::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::RecipeIngredients.def()
    }
}

impl Related<super::recipe::Entity> for Entity {
    fn to() -> RelationDef {
        super::recipe_ingredients::Relation::Recipe.def()
    }
    fn via() -> Option<RelationDef> {
        Some(super::recipe_ingredients::Relation::Product.def().rev())
    }
}

impl ActiveModelBehavior for ActiveModel {
    fn before_save<'life0, 'async_trait, C>(
        mut self,
        db: &'life0 C,
        insert: bool,
    ) -> core::pin::Pin<
        Box<
            dyn core::future::Future<Output = Result<Self, DbErr>>
                + core::marker::Send
                + 'async_trait,
        >,
    >
    where
        C: ConnectionTrait,
        C: 'async_trait,
        'life0: 'async_trait,
        Self: core::marker::Send + 'async_trait,
    {
        Box::pin(async move {
            // TODO: Add name product safety

            if let Set(price) = self.sell_price {
                match price {
                    Some(price) => {
                        if price.is_zero() || price.is_sign_negative() {
                            return Err(DbErr::Custom(
                                "Sell Price cannot be null or negative".to_string(),
                            ));
                        }
                    }
                    None => {
                        self.purchasable = Set(false);
                        self.hidden = Set(true);
                    }
                }
            }

            if let Set(None) = self.sell_price_currency {
                self.purchasable = Set(false);
                self.hidden = Set(true);
            }

            // Display Order cannot be negative
            if let Set(display_order) = self.display_order {
                if display_order < 0 {
                    self.display_order = Set(0);
                }
            }

            if let Set(purchasable) = self.purchasable {
                match purchasable {
                    true => {
                        let price_is_null = Set(None) == self.sell_price;
                        let currency_is_null = Set(None) == self.sell_price_currency;
                        let price_is_not_set = !self.sell_price.is_set();
                        let currency_is_not_set = !self.sell_price_currency.is_set();
                        let is_edit = !insert;

                        if price_is_null || currency_is_null {
                            self.purchasable = Set(false);
                            self.hidden = Set(true);
                        } else if is_edit && (price_is_not_set || currency_is_not_set) {
                            let id = self.id.clone().unwrap(); // ERROR SHOULD NEVER HAPPENED
                            let result = Entity::find_by_id(id)
                                .one(db)
                                .await?
                                .expect("Cannot find model in edition ?");

                            if result.sell_price.is_none() || result.sell_price_currency.is_none() {
                                self.purchasable = Set(false);
                                self.hidden = Set(true);
                            }
                        }
                    }
                    // A non purchasable product MUST be hidden
                    false => self.hidden = Set(true),
                }
            }

            // An non hidden product SHOULD be purchasable
            if let Set(false) = self.hidden {
                self.purchasable = Set(true);
            }

            Ok(self)
        })
    }
}
